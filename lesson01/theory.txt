Философия ООП: Что это, как и для чего

Сегодня у нас по плану:

- Какие парадигмы программировния бывают
- Отход от процедурного программирования к ООП
- Кому и как объекты упрощают жизнь, а кому усложняют
- Как придумавали объекто-оринтированную парадигму
- Чем удобнее ользовательские типы и структуры данных
- Динамическая память, указатели и сборщик мусора
- Передача по ссылке и по значению

a := 5;
print sin(a);

реальный мир

M - activeRecord
V - View
C - Controller

--------------------------------

Вася  -> расходБензина(...);
Петя ->  другойРасходБензина(...);
--------
Вася  -> расходБензина(...);
Петя ->  расходБензина(..., ...);
---------------------------------

Вопрос:
- Может ли кривой строитель из кривых кирпичей построить ровный дом? Или двигатель?
    Нет
- А из ровных кирпичей?
    Да, если умеет
- А хороший мастер из кривых?
    Да, но не удобно
- А хороший из ровных?
    Да, легко
-----------------------

Мы будем изучать мастерство. А то на каком фреймворке, каком языке, в какой парадигме - это уже не важно
=====================================

- Какие парадигмы программировния бывают

-----

Ипмератив

бездумный исполнитель
------------------

Императивное программирование
a := 5;
b := 12;
c := a + b;
print c;

Открой фотошоп
Создай документ
Удали фон
Открой фотошоп
Создай документ
Удали фон
Открой фотошоп
Создай документ
Удали фон

---------

Декларативное программирование

SELECT name FROM user ORDER BY name LIMIT 10; "Дай имена пользователей" ЧТО

---

Сделай дизайн по примерно такому макету -> ...... -> Дизайн

sum(5, 3)

print расходБензина(250, 12, а, б, t1, t2);

загрузиПользователей(10, 'name');
загрузиИменаПользователейССортировкой(10, 'name');
-------------------------

Структурное программирование

a := 5;
b := 12;
c := a + b13;
let 5;
a := 5;
b := 12;
if(b = 7) {
    goto 12;
} else {
    goto 15;
}
c := a1 + b;
a := 5;
b := 12;
c := aа + b;
if(a > 5) {
    goto 5;
}
let 12;
a := 5;
b := 12;
cc := a + b;


a := 5;
b := 12;
c := a + b13;
a := 5;
b := 12;
if(b = 7) {
    с := a1 + b;
    for(i = 1; i < 11; i++){
        a := 5;
        b := 12;
        cc := a + b;
        for(i = 1; i < 11; i++){
            a := 5;
            b := 12;
            cc := a + b;
        }
    }
} else {
    b := c + a;
}
c := a1 + b;
a := 5;
b := 12;
c := aа + b;



Принципы:

- Следует отказаться от использования оператора безусловного оператора goto.
- Любая программа строиться из 3х базовых управляющих конструкций: последовательность, ветвление, цикл.
- В программе базовые управляющие конструкции могут быть вложены друг в друга произвольным образом.
- Каждую логическую законченную группу инструкций следует оформить как блок(block).
- Разработка кода ведеться пошагово, методом "Сверху-вниз"

procedure init() {
    ...
}

function process(a, b) {
    if(...) {
        b = 7;
        c = a + b;
        for(...) {
            if(...) {
                c = a + b;
            }
        }
    } else {
        b = 7;
        c = 16;
    }
    return a;
}

init();
a := process();
export(a);

---------------------

-> [    ] -> [    ] -> [    ] -> [    ] -> [    ] -> [    ] -> [    ] -> [    ] ->

------

Процедурное програмирование (подход)
    Разнесение кода по процедурам и функциям

students = loadStudentFromFile(file);
filteredStudents := [];
result := '';
forEach(students as student) {
    if (isOchn(student)) {
        filteredStudents[] = student;
    }
}
forEach(filteredStudents as student) {
    result := result + ', ' + getFullName(student);
}
print(result);

-------------------------------------------------------------------------------------------

    Функциональное программирование     |       Объектно-ориентированное программирование

-------------------------------------------------------------------------------------------

print
    reduce(join,
         map(getFullName,
            filter(isOchn,
                loadStudentFromFile(file))));

function map($func, $items) {
    $result = [];
    forEach($items as $item) {
        $result[] = $func($items);
    }
    return $result;
}

$items = [2, 5, 3, 16, 7];

$square = function($a) {
    return $a * $a;
}

print_r(array_map($square, $items)); // [4, 25, 9, 256, 49]

---------

function map($func, $items) {

    if(count($items) > 1)  {
    return array_merge(
        [$func(reset($item))],
        map($func, array_slice($items, 1))
    ); // [4, map(5,3,16,7)]
    } else {
        return $items;
    }
}

============================================

- Лапшекод
- Процедуры облегчили лапшекод
- Неудобство сотен тысяч процедур
- Разрозненность данных
- Компоневка по смыслу

-------------------------------------------

$отделКадров->наймиСотрудника($данныеСотрудника);

=======================================

Хорошее ООП
    Разгружает голову
    Привносит модульность
    Повышает совместимость
    Локализуем изменения
    Абстрагируется от реализации
    Упрощает код
    Легко тестируется

Недо ООП
    Приносить сложность
    Сохраняет процедурный подход
    Причиняет неудобство
    Т.е. никакой пользы не привносит